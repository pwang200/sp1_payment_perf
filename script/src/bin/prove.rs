//! An end-to-end example of using the SP1 SDK to generate a proof of a program that can be verified
//! on-chain.
//!
//! You can run this script using the following command:
//! ```shell
//! RUST_LOG=info cargo run --package fibonacci-script --bin prove --release
//! ```

// use std::path::PathBuf;

// use alloy_sol_types::{sol, SolType};
use clap::Parser;
// use hex;
// use serde::{Deserialize, Serialize};
use sp1_sdk::{ProverClient, SP1Stdin};
// use sp1_sdk::{HashableKey, ProverClient, SP1ProofWithPublicValues, SP1Stdin, SP1VerifyingKey};

use common::common::*;
use rand::rngs::OsRng;


/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const FIBONACCI_ELF: &[u8] = include_bytes!("../../../program/elf/riscv32im-succinct-zkvm-elf");

#[derive(Parser, Debug)]
// #[command(version, about, long_about = None)]
struct Args {
    #[arg(short, long, default_value_t = 2)]
    network_size: usize,

    #[arg(short, long, default_value_t = 1)]
    transactions: usize,
}

fn create_input(network_size: usize, num_txns: usize) -> EngineData {
    let mut csprng = OsRng;
    let mut signers = vec![];
    let mut keys = vec![];
    for _ in 0..network_size {
        let f = TxSigner::new(SigningKey::random(&mut csprng));
        keys.push(f.pk);
        signers.push(f);
    }
    let mut engine_data = EngineData::new_batch(keys, 1_000_000_000_000);

    let mut txns = vec![];
    let amount = 1u128;
    for i in 0..num_txns {
        let to = signers[(i + 1) % network_size].pk;
        let from = &mut signers[i % network_size];
        txns.push(Transaction::Pay(Tx::new(from.pk, from.sqn, Payment { to, amount }, &mut from.sk)));
        from.sqn += 1;
    }
    engine_data.txns = txns;
    engine_data.get_partial()
}

fn main() {
    let args = Args::parse();
    println!("network size: {}, number of transactions: {}", args.network_size, args.transactions);
    assert!(args.network_size > 0 && args.transactions > 0);
    let input = create_input(args.network_size, args.transactions);
    assert!(input.account_book.verify_partial_root());

    sp1_sdk::utils::setup_logger();
    let client = ProverClient::new();

    // Setup the program.
    let (pk, vk) = client.setup(FIBONACCI_ELF);

    // Setup the inputs.
    let mut stdin = SP1Stdin::new();
    stdin.write(&input);


    let time_start = clock();
    let proof = client
            .prove(&pk, stdin)
            .run()
            .expect("failed to generate proof");

    let time = clock() - time_start;
    println!("Prover, prove time {}", time / 1000);

    let time_start = clock();
    client.verify(&proof, &vk).expect("failed to verify proof");
    let time = clock() - time_start;
    println!("Prover, verify time {}", time );

    // let header: BlockHeaderL2 = ;
    // let host_header = common::l2_engine::process(&mut input).expect("native run");
    // if header.hash() != host_header.hash() {
    //     println!("Prover, header hash: {:?}", header.hash());
    //     println!("Host,   header hash: {:?}", host_header.hash());
    // }
}



// /// The arguments for the prove command.
// #[derive(Parser, Debug)]
// #[clap(author, version, about, long_about = None)]
// struct ProveArgs {
//     #[clap(long, default_value = "2")]
//     n: u32,
//
//     #[clap(long, default_value = "false")]
//     evm: bool,
// }
//
// /// The public values encoded as a tuple that can be easily deserialized inside Solidity.
// type PublicValuesTuple = sol! {
//     tuple(uint32, uint32, uint32)
// };
//
// fn main() {
//     // Setup the logger.
//     sp1_sdk::utils::setup_logger();
//
//     // Parse the command line arguments.
//     let args = ProveArgs::parse();
//
//     // Setup the prover client.
//     let client = ProverClient::new();
//
//     // Setup the program.
//     let (pk, vk) = client.setup(FIBONACCI_ELF);
//
//     // Setup the inputs.
//     let mut stdin = SP1Stdin::new();
//     stdin.write(&args.n);
//
//     println!("n: {}", args.n);
//
//     if args.evm {
//         // Generate the proof.
//         let proof = client
//             .prove(&pk, stdin)
//             .plonk()
//             .run()
//             .expect("failed to generate proof");
//         create_plonk_fixture(&proof, &vk);
//     } else {
//         // Generate the proof.
//         let proof = client
//             .prove(&pk, stdin)
//             .run()
//             .expect("failed to generate proof");
//         let (_, _, fib_n) =
//             PublicValuesTuple::abi_decode(proof.public_values.as_slice(), false).unwrap();
//         println!("Successfully generated proof!");
//         println!("fib(n): {}", fib_n);
//
//         // Verify the proof.
//         client.verify(&proof, &vk).expect("failed to verify proof");
//     }
// }
//
// /// A fixture that can be used to test the verification of SP1 zkVM proofs inside Solidity.
// #[derive(Debug, Clone, Serialize, Deserialize)]
// #[serde(rename_all = "camelCase")]
// struct SP1FibonacciProofFixture {
//     a: u32,
//     b: u32,
//     n: u32,
//     vkey: String,
//     public_values: String,
//     proof: String,
// }
//
// /// Create a fixture for the given proof.
// fn create_plonk_fixture(proof: &SP1ProofWithPublicValues, vk: &SP1VerifyingKey) {
//     // Deserialize the public values.
//     let bytes = proof.public_values.as_slice();
//     let (n, a, b) = PublicValuesTuple::abi_decode(bytes, false).unwrap();
//
//     // Create the testing fixture so we can test things end-ot-end.
//     let fixture = SP1FibonacciProofFixture {
//         a,
//         b,
//         n,
//         vkey: vk.bytes32().to_string(),
//         public_values: format!("0x{}", hex::encode(bytes)),
//         proof: format!("0x{}", hex::encode(proof.bytes())),
//     };
//
//     // The verification key is used to verify that the proof corresponds to the execution of the
//     // program on the given input.
//     //
//     // Note that the verification key stays the same regardless of the input.
//     println!("Verification Key: {}", fixture.vkey);
//
//     // The public values are the values whicha are publically commited to by the zkVM.
//     //
//     // If you need to expose the inputs or outputs of your program, you should commit them in
//     // the public values.
//     println!("Public Values: {}", fixture.public_values);
//
//     // The proof proves to the verifier that the program was executed with some inputs that led to
//     // the give public values.
//     println!("Proof Bytes: {}", fixture.proof);
//
//     // Save the fixture to a file.
//     let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../contracts/src/fixtures");
//     std::fs::create_dir_all(&fixture_path).expect("failed to create fixture path");
//     std::fs::write(
//         fixture_path.join("fixture.json"),
//         serde_json::to_string_pretty(&fixture).unwrap(),
//     )
//     .expect("failed to write fixture");
// }
